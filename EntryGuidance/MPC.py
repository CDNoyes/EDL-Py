""" 
Model Predictive Controllers

    Standard NMPC - use a prediction model to optimize a bank profile over a receding horizon
    Joel's NMPC - use the taylor expansion of the current state to predict a future state, and determines the optimal control over the interval
    Robust NMPC - adds a feedback control element to the nominal solution generated by an open-loop NMPC
    
"""

# Elements: 
#   Optimization:
#       propagation of prediction model for a given control sequence -  controller needs to be passed a system model and initial state
#       computation of some cost function (generally difference between predicted states and reference states) - controller needs reference data in some format, or possibly just pass a cost function that takes standard arguments
#       iteration to improve control sequence until convergence - need a reliable optimization routine (although with smaller parametrizations, brute force could even be used)

from scipy.integrate import odeint, trapz
from scipy.optimize import minimize, differential_evolution
from functools import partial
from numpy import pi
import numpy as np

def constant(value, **kwargs):
    return value

def options(N,T):
    """ Defines the parameters used in NMPC """
    opt = {}
    
    opt['N'] = N            # Integer number of time steps to predict forward, also the number of control segments
    opt['T'] = T            # Total prediction length
    
    opt['dt'] = float(T)/N  # Length of each step in the prediction
    
    return opt


def controller(control_options, control_bounds, aero_ratios, reference, **kwargs):

    bounds = [control_bounds]*control_options['N']    
    
    sol = optimize(kwargs['current_state'], control_options, bounds, aero_ratios, reference)

    return sol.x[0]
    
def optimize(current_state, control_options, control_bounds, aero_ratios, reference):
    from Simulation import Simulation, NMPCSim
    
    
    sim = Simulation(output=False, **NMPCSim(control_options))

    guess = [pi/4]*control_options['N']
    sol = minimize(cost, guess, args=(sim, current_state, aero_ratios, reference), 
                   method='L-BFGS-B', bounds=control_bounds, tol=1e-2, options={'disp':False}) # Seems to work okay!
                   
    # sol = minimize(cost, guess, args=(sim, x0), method='SLSQP', bounds=bounds, tol=1e-2, options={'disp':True}) # Seems to work okay, but not as well as BFGS
    # sol = differential_evolution(cost, args=(sim, x0), bounds=bounds, tol=1e-1, disp=True)
    
    
    return sol
    
def cost(u, sim, state, ratios, reference):

    controls = [partial(constant, value=v) for v in u]
    output = sim.run(state, controls, None, ratios)
    time = output[:,0]
    drag = output[:,13]
    vel = output[:,7]
    # lift = output[:,12]
    
    drag_ref = reference(vel)
    
    integrand = (drag-drag_ref)**2
    return trapz(integrand, time)
    
    
def testNMPC():
    from Simulation import Simulation, Cycle, EntrySim, SRP
    import matplotlib.pyplot as plt
    from ParametrizedPlanner import HEPBank
    # from JBG import controller as srp_control
    from Triggers import AccelerationTrigger, VelocityTrigger
    
    # Plan the nominal profile:
    reference_sim = Simulation(cycle=Cycle(1),output=False,**EntrySim())
    bankProfile = lambda **d: HEPBank(d['time'],*[ 165.4159422 ,  308.86420218,  399.53393904])
    
    r0, theta0, phi0, v0, gamma0, psi0,s0 = (3540.0e3, np.radians(-90.07), np.radians(-43.90),
                                             5505.0,   np.radians(-14.15), np.radians(4.99),   1000e3)
                                             
    x0 = np.array([r0, theta0, phi0, v0, gamma0, psi0, s0, 8500.0])
    output = reference_sim.run(x0,[bankProfile])

    drag_ref = reference_sim.getRef()
    
    
    # Create the simulation model:
        
    states = ['PreEntry','Entry']
    conditions = [AccelerationTrigger('drag',2), VelocityTrigger(500)]
    input = { 'states' : states,
              'conditions' : conditions }
              
    sim = Simulation(cycle=Cycle(1),output=True,**input)

    # Create the controllers
    
    option_dict = options(N=3,T=15)
    mpc = partial(controller,control_options=option_dict, control_bounds=(0,pi/2), aero_ratios=(1,1), reference=drag_ref)
    pre = partial(constant,value=bankProfile(time=0))
    controls = [pre,mpc]
    output = sim.run(x0,controls)
    
    sim.plot()
    sim.show()
    
    
if __name__ == '__main__':
    testNMPC()