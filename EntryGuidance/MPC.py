""" 
Model Predictive Controllers

    Standard NMPC - use a prediction model to optimize a bank profile over a receding horizon
    Joel's NMPC - use the taylor expansion of the current state to predict a future state, and determines the optimal control over the interval
    Robust NMPC - adds a feedback control element to the nominal solution generated by an open-loop NMPC
    
"""

# Elements: 
#   Optimization:
#       propagation of prediction model for a given control sequence -  controller needs to be passed a system model and initial state
#       computation of some cost function (generally difference between predicted states and reference states) - controller needs reference data in some format, or possibly just pass a cost function that takes standard arguments
#       iteration to improve control sequence until convergence - need a reliable optimization routine (although with smaller parametrizations, brute force could even be used)

from scipy.integrate import odeint, trapz
from scipy.optimize import minimize, differential_evolution, minimize_scalar
from functools import partial
from numpy import pi
import numpy as np

def constant(value, **kwargs):
    return value

def options(N,T):
    """ Defines the parameters used in NMPC """
    opt = {}
    
    opt['N'] = N            # Integer number of time steps to predict forward, also the number of control segments
    opt['T'] = T            # Total prediction length
    
    opt['dt'] = float(T)/N  # Length of each step in the prediction
    
    return opt


def controller(control_options, control_bounds, references, desired_heading, **kwargs):
    
    newSign,clipBounds = lateral(np.sign(kwargs['bank']), kwargs['velocity'], kwargs['drag'], kwargs['fpa'], kwargs['heading'], kwargs['latitude'], kwargs['longitude'], control_options['T'], references['bank'], desired_heading)
    
    if clipBounds and True:
        bounds = [(control_bounds[0],np.abs(kwargs['bank']))]*control_options['N']
    else:
        bounds = [control_bounds]*control_options['N']    
    
    if True:
        control_options['T'] = np.round(15/(np.log(kwargs['drag'])/2-0.3)) # Schedule this by dynamic pressure
        print "Predict horizon = {}".format(control_options['T'])
        
    sol = optimize(kwargs['current_state'], control_options, bounds, kwargs['aero_ratios'], references)
    
    # print "Aero ratios used in controller: {},{}".format(*kwargs['aero_ratios'])
    if control_options['N'] > 1:
        return sol.x[0]*np.sign(references['bank'](kwargs['velocity']))
    else:
        return sol.x*newSign

def lateral(bank_sign, velocity, drag, fpa, heading, latitude, longitude, T, bankRef, compute_heading):

    vdot = -drag-3.7*np.sin(fpa)
    vf = velocity + T*vdot # Approximation, could also used the actual model to predict
    dv = velocity-vf
    
    bank = bankRef([velocity,vf])
    if False and bank[0]*bank[1] < 0: #Sign change occurs within the prediction interval
        # v = np.linspace(velocity,vf)
        # b = bankRef(v)
        # ind = np.where(np.diff(np.sign(b)))[0]
        # vr = v[ind[0]]
        # dvf = velocity-vr
        # factor = (dvf/vf)
        # factor = 0
        print "Anticipating bank reversal"

        return bank_sign, True
    else:
        heading_desired = compute_heading(longitude,latitude)
        # print "Heading error: {} deg".format(np.degrees(heading-heading_desired))
        if np.abs(heading-heading_desired)>.07:
            return np.sign(heading-heading_desired), False # Any reason to clip if we're commanding a change already?
        else:        
            return bank_sign, False
    
    
        
def optimize(current_state, control_options, control_bounds, aero_ratios, reference):
    from Simulation import Simulation, NMPCSim
    
    
    sim = Simulation(output=False, **NMPCSim(control_options))

    guess = [pi/6]*control_options['N']
    if control_options['N'] > 1:
        scalar = False
        # sol = minimize(cost, guess, args=(sim, current_state, aero_ratios, reference), 
                       # method='L-BFGS-B', bounds=control_bounds, tol=1e-2, options={'disp':False}) # Seems to work okay!
        sol = minimize(cost, guess, args=(sim, current_state, aero_ratios, reference, scalar), 
                       method='SLSQP', bounds=control_bounds, tol=1e-4, options={'disp':False}) # Seems to work okay!               
    # sol = differential_evolution(cost, args=(sim, x0), bounds=bounds, tol=1e-1, disp=True)
    else:
        scalar = True
        sol = minimize_scalar(cost, method='Bounded', bounds=control_bounds[0], args=(sim, current_state, aero_ratios, reference, scalar))
        # plotCost(sim,current_state,reference,sol)
        # plotRTG(sim, current_state, reference, sol.x)
        
    return sol
    
def cost(u, sim, state, ratios, reference, scalar):
    if scalar:
        controls = [partial(constant,value=u)]
    else:
        controls = [partial(constant, value=v) for v in u]
    output = sim.run(state, controls, AeroRatios=ratios)
    time = output[:,0]
    drag = output[:,13]
    vel = output[:,7]
    alt = output[:,3]
    # range = output[:,10]
    rangeToGo = sim.history[:,6]/1000.
    fpa = np.radians(output[:,8])
    # lift = output[:,12]
    
    if 1:                                   # Pure drag tracking
        drag_ref = reference['drag'](vel)
        integrand = 1*(drag-drag_ref)**2
    # else:
        # drag_ref = reference['dragcos'](vel) # Tracking D/cos(fpa) - which is the true integrand in energy integral
        # integrand = 1*(drag/np.cos(fpa)-drag_ref)**2
    
    if  vel[0]<5300 and True:                                  # Add range to go, like an integral term in PID. Shouldn't start until the reference makes sense
        rtg_ref = reference['rangeToGo'](vel)/1000. # Meters to Km
        integrand += .1*(rangeToGo-rtg_ref)**2
    
    if 0:
        alt_ref = reference['altitude'](vel)
        integrand = (alt-alt_ref)**2
    
    return trapz(integrand, time)
 
def plotRTG(sim,state,reference,sol): 
    import matplotlib.pyplot as plt
    
    controls = [partial(constant,value=sol)]
    output = sim.run(state, controls, AeroRatios=(1,1))
    time = output[:,0]
    drag = output[:,13]
    vel = output[:,7]
    rangeToGo = sim.history[:,6]/1000.

    
    rtg_ref = reference['rangeToGo'](vel)/1000. # Meters to Km
    
    plt.plot(vel, rangeToGo,label='MPC')
    plt.plot(vel, rtg_ref,label='Ref')
    plt.show()
    
    
def plotCost(sim,state,reference,sol):
    import matplotlib.pyplot as plt
    
    U = np.linspace(0,np.pi/2)
    c = [cost(u, sim, state, (1,1), reference, True) for u in U]
    plt.plot(np.degrees(U),np.array(c)/np.max(c))
    # plt.plot(np.degrees(sol.x), sol.fun/np.max(c),'x')
    plt.xlabel('Bank Angle (deg)')
    plt.ylabel('Cost Function (Normalized to Max Cost = 1)')
    plt.title('Cost as a function of constant control over the prediction horizon')
    # plt.show()
    
def testNMPC():
    from Simulation import Simulation, Cycle, EntrySim, SRP
    import matplotlib.pyplot as plt
    from ParametrizedPlanner import HEPBank,HEPBankReducedSmooth
    import HeadingAlignment as headAlign
    from Triggers import AccelerationTrigger, VelocityTrigger, RangeToGoTrigger, SRPTrigger
    from Uncertainty import getUncertainty
    
    # Plan the nominal profile:
    reference_sim = Simulation(cycle=Cycle(1),output=False,**EntrySim())
    # bankProfile = lambda **d: HEPBankReducedSmooth(d['time'],*[ 165.4159422 ,  308.86420218])
    bankProfile = lambda **d: HEPBank(d['time'],*[ 165.4159422 ,  308.86420218,  399.53393904], minBank=np.radians(35))
    # bankProfile = lambda **d: np.sin(d['time']/20)
    
    r0, theta0, phi0, v0, gamma0, psi0,s0 = (3540.0e3, np.radians(-90.07), np.radians(-43.90),
                                             5505.0,   np.radians(-14.15), np.radians(4.99),   1000e3)
                                             
    x0 = np.array([r0, theta0, phi0, v0, gamma0, psi0, s0, 2800.0])
    output = reference_sim.run(x0,[bankProfile])

    references = reference_sim.getRef()
    drag_ref = references['drag']
    
    
    # Create the simulation model:
        
    states = ['PreEntry','RangeControl','Heading']
    # conditions = [AccelerationTrigger('drag',4), VelocityTrigger(1300), VelocityTrigger(500)]
    # conditions = [AccelerationTrigger('drag',4), VelocityTrigger(1300), RangeToGoTrigger(0)]
    conditions = [AccelerationTrigger('drag',4), VelocityTrigger(1300), SRPTrigger(2,700)]
    input = { 'states' : states,
              'conditions' : conditions }
              
    sim = Simulation(cycle=Cycle(1),output=True,**input)

    # Create the controllers
    
    option_dict = options(N=1,T=5)
    get_heading = partial(headAlign.desiredHeading, lat_target=np.radians(output[-1,6]),lon_target=np.radians(output[-1,5]))
    mpc_heading = partial(headAlign.controller, control_options=option_dict, control_bounds=(-pi/2,pi/2), get_heading=get_heading)
    mpc_range = partial(controller, control_options=option_dict, control_bounds=(0,pi/1.5), references=references, desired_heading=get_heading)
    pre = partial(constant, value=bankProfile(time=0))
    controls = [pre,mpc_range,mpc_heading]
    
    # Run the off-nominal simulation
    perturb = getUncertainty()['parametric']
    # sample = None 
    # sample = perturb.sample()
    # print sample
    sample = [ -0.05,  0.01,  -0.02, -0.004]
    s0 = reference_sim.history[0,6]-reference_sim.history[-1,6] # This ensures the range to go is 0 at the target for the real simulation
    x0_nav = [r0, theta0, phi0, v0, gamma0, psi0, s0, 2800.0] # Errors in velocity and mass
    x0_full = np.array([r0, theta0, phi0, v0, gamma0, psi0, s0, 2800.0] + x0_nav + [1,1] + [np.radians(-15),0])

    if 0:
        output = sim.run(x0, controls, sample, FullEDL=False)
        plt.show()
        
        reference_sim.plot()

    else:
        output = sim.run(x0_full, controls, sample, FullEDL=True)
        plt.show()

        reference_sim.plot()

    Dref = drag_ref(output[:,7])
    D = output[:,13]    
    Derr = D-Dref
    DerrPer = 100*Derr/Dref
    Ddotref = np.diff(Dref)/np.diff(output[:,0])
    Dddotref = np.diff(Dref,n=2)/np.diff(output[1:,0])
   
    iv = np.nonzero(output[:,7]<5400)[0]
    
    plt.figure(60)
    # plt.plot(output[iv,7],DerrPer[iv])
    plt.plot(output[iv,7],D[iv],label='Actual')
    plt.plot(output[iv,7],Dref[iv],label='Reference')
    plt.ylabel('Drag Error (m/s^2)')
    plt.xlabel('Velocity (m/s)')
    plt.legend()
    
    sim.plot(compare=False)
    sim.show()
    
    
if __name__ == '__main__':
    testNMPC()