""" 
Model Predictive Controllers

    Standard NMPC - use a prediction model to optimize a bank profile over a receding horizon
    Joel's NMPC - use the taylor expansion of the current state to predict a future state, and determines the optimal control over the interval
    Robust NMPC - adds a feedback control element to the nominal solution generated by an open-loop NMPC
    
"""

# Elements: 
#   Optimization:
#       propagation of prediction model for a given control sequence -  controller needs to be passed a system model and initial state
#       computation of some cost function (generally difference between predicted states and reference states) - controller needs reference data in some format, or possibly just pass a cost function that takes standard arguments
#       iteration to improve control sequence until convergence - need a reliable optimization routine (although with smaller parametrizations, brute force could even be used)

from scipy.integrate import trapz
from scipy.optimize import minimize, differential_evolution, minimize_scalar
from functools import partial
from numpy import pi
import numpy as np

def constant(value, **kwargs):
    return value

def options(N,T):
    """ Defines the parameters used in NMPC. Set T = None for a variable prediction horizon based on dynamic pressure. """
    opt = {}
    
    opt['N'] = N            # Integer number of time steps to predict forward, also the number of control segments
    opt['T'] = T            # Total prediction length
    opt['T0'] = T           # Copy of the input, since T may change.
    return opt


def controller(control_options, control_bounds, references, desired_heading, **kwargs):
    
    newSign,clipBounds = lateral(np.sign(kwargs['bank']), kwargs['velocity'], kwargs['drag'], kwargs['fpa'], kwargs['heading'], kwargs['latitude'], kwargs['longitude'], control_options['T'], references['bank'], desired_heading)
    
    if clipBounds and True:
        bounds = [(control_bounds[0],np.abs(kwargs['bank']))]*control_options['N']
    else:
        bounds = [control_bounds]*control_options['N']    
    
    if control_options['T0'] is None:
        control_options['T'] = np.clip(np.round(15/(np.log(kwargs['drag'])/2-0.3)), 3, 30) # Schedule this by dynamic pressure
        print "Predict horizon = {}".format(control_options['T'])
        
    sol = optimize(kwargs['current_state'], control_options, bounds, kwargs['aero_ratios'], references)
    
    # print "Aero ratios used in controller: {},{}".format(*kwargs['aero_ratios'])
    if control_options['N'] > 1:
        return sol.x[0]*np.sign(references['bank'](kwargs['velocity']))
    else:
        return sol.x*newSign

def lateral(bank_sign, velocity, drag, fpa, heading, latitude, longitude, T, bankRef, compute_heading):

    # vdot = -drag-3.7*np.sin(fpa)
    # vf = velocity + 5*vdot # Approximation, could also used the actual model to predict
    # dv = velocity-vf

    heading_desired = compute_heading(longitude,latitude)
    # print "Heading error: {} deg".format(np.degrees(heading-heading_desired))
    if np.abs(heading-heading_desired)>.07:
        return np.sign(heading-heading_desired), False # Any reason to clip if we're commanding a change already?
    else:        
        return bank_sign, False
    
    
        
def optimize(current_state, control_options, control_bounds, aero_ratios, reference):
    from Simulation import Simulation, NMPCSim
    
    
    sim = Simulation(output=False, find_transitions=False, **NMPCSim(control_options))

    guess = [pi/6]*control_options['N']
    if control_options['N'] > 1:
        scalar = False
        # sol = minimize(cost, guess, args=(sim, current_state, aero_ratios, reference), 
                       # method='L-BFGS-B', bounds=control_bounds, tol=1e-2, options={'disp':False}) # Seems to work okay!
        sol = minimize(cost, guess, args=(sim, current_state, aero_ratios, reference, scalar), 
                       method='SLSQP', bounds=control_bounds, tol=1e-4, options={'disp':False}) # Seems to work okay!               
    # sol = differential_evolution(cost, args=(sim, x0), bounds=bounds, tol=1e-1, disp=True)
    else:
        scalar = True
        sol = minimize_scalar(cost, method='Bounded', bounds=control_bounds[0], args=(sim, current_state, aero_ratios, reference, scalar))
        # plotCost(sim,current_state,reference,sol)
        # plotRTG(sim, current_state, reference, sol.x)
        
    return sol
    
def cost(u, sim, state, ratios, reference, scalar):
    if scalar:
        controls = [partial(constant,value=u)]
    else:
        controls = [partial(constant, value=v) for v in u]
    output = sim.run(state, controls, AeroRatios=ratios)
    time = output[:,0]
    drag = output[:,13]
    vel = output[:,7]
    alt = output[:,3]
    radius = output[:,4]
    energy = output[:,1]
    # dE = energy[0]-energy[-1]
    # range = output[:,10]
    rangeToGo = sim.history[:,6]/1000.
    fpa = np.radians(output[:,8])
    # lift = output[:,12]
    
    if 1:
        if 0:                                                     
            drag_ref = reference['drag'](vel)                     # Pure drag tracking as function of velocity
            integrand = 1*(drag-drag_ref)**2
        elif 1:
            drag_ref = reference['drag_energy'](energy)
            integrand = 1*(drag-drag_ref)**2
        elif 0:
            drag_ref = reference['dragcos'](energy)               # Tracking D/cos(fpa) - which is the true integrand in energy integral
            # integrand = 1*(drag/np.cos(fpa)-drag_ref)**2
            integrand = 1*(drag-drag_ref)**2
        else:
            fpa_ref = reference['fpa'](vel[-1])                     # Flight path tracking as function of velocity
            return (fpa[-1]-fpa_ref)**2
        
        if vel[0]<5300 and False:                                  # Add range to go, like an integral term in PID. Shouldn't start until the reference makes sense
            rtg_ref = reference['rangeToGo'](vel)/1000.           # Meters to Km
            integrand += .1*(rangeToGo-rtg_ref)**2
            
        if vel[0]<5300 and False:                                  # Add drag rate, like an derivative term in PID. Shouldn't start until the reference makes sense
            drag_rate_ref = reference['drag_rate'](vel)
            drag_rate = np.insert(np.diff(drag)/np.diff(time), 0, drag_rate_ref[0])
            integrand += 40/vel[0]*(drag_rate-drag_rate_ref)**2    
    
    # if 0:
        # alt_ref = reference['altitude'](vel)
        # integrand = (alt-alt_ref)**2
    else:    
        alt_ref = reference['altitude_range'](rangeToGo*1000)
        integrand = 1*(alt-alt_ref)**2        
    
    return trapz(integrand, time)
 
def plotRTG(sim,state,reference,sol): 
    import matplotlib.pyplot as plt
    
    controls = [partial(constant,value=sol)]
    output = sim.run(state, controls, AeroRatios=(1,1))
    time = output[:,0]
    drag = output[:,13]
    vel = output[:,7]
    rangeToGo = sim.history[:,6]/1000.

    
    rtg_ref = reference['rangeToGo'](vel)/1000. # Meters to Km
    
    plt.plot(vel, rangeToGo,label='MPC')
    plt.plot(vel, rtg_ref,label='Ref')
    plt.show()
    
    
def plotCost(sim,state,reference,sol):
    import matplotlib.pyplot as plt
    
    U = np.linspace(0,np.pi/2)
    c = [cost(u, sim, state, (1,1), reference, True) for u in U]
    plt.plot(np.degrees(U),np.array(c)/np.max(c))
    # plt.plot(np.degrees(sol.x), sol.fun/np.max(c),'x')
    plt.xlabel('Bank Angle (deg)')
    plt.ylabel('Cost Function (Normalized to Max Cost = 1)')
    plt.title('Cost as a function of constant control over the prediction horizon')
    # plt.show()
    
def testNMPC():
    from scipy.io import savemat, loadmat
    import matplotlib.pyplot as plt
    
    from Simulation import Simulation, Cycle, EntrySim, SRP
    from ParametrizedPlanner import HEPBank,HEPBankSmooth
    import HeadingAlignment as headAlign
    from Triggers import AccelerationTrigger, VelocityTrigger, RangeToGoTrigger, SRPTrigger
    from Uncertainty import getUncertainty
    from InitialState import InitialState
    
    # Plan the nominal profile:
    reference_sim = Simulation(cycle=Cycle(1),output=False,**EntrySim())
    # bankProfile = lambda **d: HEPBankReducedSmooth(d['time'],*[ 165.4159422 ,  308.86420218])
    bankProfile = lambda **d: HEPBankSmooth(d['time'],*[99.67614316,  117.36691891,  146.49573609], minBank=np.radians(30))
    # bankProfile = lambda **d: np.sin(d['time']/20)
                                                
    x0 = InitialState()
    output = reference_sim.run(x0,[bankProfile])

    references = reference_sim.getRef()
    drag_ref = references['drag']
    # reference_sim.plot(plotEnergy=True)
    # plt.show()
    
    if 1:
        # Create the simulation model:
            
        states = ['PreEntry','RangeControl','HeadingAlign']
        # conditions = [AccelerationTrigger('drag',4), VelocityTrigger(1300), VelocityTrigger(500)]
        # conditions = [AccelerationTrigger('drag',4), VelocityTrigger(1300), RangeToGoTrigger(0)]
        conditions = [AccelerationTrigger('drag',2), VelocityTrigger(1400), SRPTrigger(0.5,700,500)]
        input = { 'states' : states,
                  'conditions' : conditions }
                  
        sim = Simulation(cycle=Cycle(1), output=True, **input)

        # Create the controllers
        
        # option_dict = options(N=1,T=None)
        option_dict = options(N=1,T=10)
        option_dict_heading = options(N=1,T=10)
        get_heading = partial(headAlign.desiredHeading, lat_target=np.radians(output[-1,6]), lon_target=np.radians(output[-1,5]))
        
        mpc_heading = partial(headAlign.controller, control_options=option_dict_heading, control_bounds=(-pi/2,pi/2), get_heading=get_heading)
        mpc_range = partial(controller, control_options=option_dict, control_bounds=(0,pi/1.5), references=references, desired_heading=get_heading)
        pre = partial(constant, value=bankProfile(time=0))
        controls = [pre, mpc_range, mpc_heading]
        
        # Run the off-nominal simulation
        perturb = getUncertainty()['parametric']
        # sample = None 
        sample = perturb.sample()
        # sample = [.1,-.1,-.05,0]
        print sample

        s0 = reference_sim.history[0,6]-reference_sim.history[-1,6] # This ensures the range to go is 0 at the target for the real simulation
        x0_full = InitialState(1) 


        reference_sim.plot(plotEnergy=True)

        output = sim.run(x0_full, controls, sample, FullEDL=True)
        sim.plot(compare=False)

        
        sim.show()
    
    
if __name__ == '__main__':
    testNMPC()